---
title: "[eb1] Measurement - Quality Control"
author: "Egor Ananyev"
date: "2019-01-04"
output:
    html_document:
        toc: true
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body, td{
  font-family: Cambria;
}
code.r{
  font-family: Inconsolata;
}
</style>

# Data input and parsing
```{r set-options, message=F}
options(width=80)
dropbox_dir = '/Users/Egor/Dropbox/' # Mac / Toshi
# dropbox_dir = '/Users/egora/Dropbox/' # Shocky
data_dir = paste0(dropbox_dir, 'Projects/eb/data/eb1')
this_subj = 'subj-00'
this_cond = 'cond-m'
cond_dir = paste(data_dir, this_subj, this_cond, sep='/')
all_data_dirs = list.dirs(cond_dir)[-1]  # excluding the first (base) directory
# TEMP: for now, just taking the last directory:
this_data_dir = all_data_dirs[length(all_data_dirs)]
file_name = dir(this_data_dir, pattern='.asc.gz')
file_path = paste(this_data_dir, file_name, sep='/')
```

```{r}
# Read in the data:
raw_file = gzfile(file_path)
raw_data = readLines(raw_file)  # gzfile unpacks .gz
close(raw_file)

# This function converts a specific chunk of raw data into a numeric data frame.
dfy = function(df_in, cols, space_col=0){
    ## The 'cols' parameter identifies the number of columns that are tab-delimited
    ## The 'space_col' parameter allows specification of _one_ column to delimit by space
    if(space_col == 0){
        # split the dataset by the tab '\t' delimeter:
        df_out = do.call(rbind, strsplit(df_in, '\t'))[,cols]
    }else{
        # split the dataset by the tab '\t' delimeter:
        df_out = data.frame(do.call(rbind, strsplit(df_in, "\t", fixed=TRUE)))
        # split the data set by space ' ' delimeter:
        df_out = cbind(df_out, data.frame(do.call(rbind, 
                                                  strsplit(as.character(df_out[,space_col])," ", 
                                                           fixed=TRUE))))
        df_out = df_out[,cols]
    }
    # We then convert the resulting character matrix into a numeric data frame:
    if(is.null(dim(df_out))){  # if there is only a single dimension (i.e., a list), no need for 'apply'
        df_out = as.numeric(df_out)
    }else{  # otherwise, 'apply'ing 'as.numeric' conversion to columns:
        if(space_col == 0){
            # To avoid the 'conversion to NA' warning, preassigning blink-related ROWS to NAs:
            df_out[df_out=='   .'] = NA
            df_out = data.frame(apply(df_out[,cols], 2, as.numeric))
        }else{
            df_out = data.frame(apply(df_out, 2, as.numeric))
        }
    }
    return(df_out)
}
```

## Samples
```{r}
# extracting lines that start with numbers:
samples_raw = raw_data[grepl('^[0-9]', raw_data)]
# creating a proper data frame:
samples = dfy(samples_raw, 1:4, 0)  # we only need 4 cols, and no columns are space-delimited
colnames(samples) = c('sample', 'xr', 'yr', 'psr')
print(head(samples))
```

## Once-per-trial events
```{r}
# Storing the start and end trials times:
trials = data.frame(start=dfy(raw_data[grepl('TRIAL_START', raw_data)], c(3,5), 2),
                       end=dfy(raw_data[grepl('TRIAL_END', raw_data)], c(3,5), 2))
# Adding cue onset time:
trials = cbind(trials, 
               data.frame(cue_onset=dfy(raw_data[grepl('CUE_ONSET', raw_data)], c(3,5), 2)))
# Adding blink latency onset time:
trials = cbind(trials, 
               data.frame(blink_latency=dfy(raw_data[grepl('BLINK_LATENCY_ONSET', raw_data)], 
                                            c(3,5), 2)))
# Adding blink window onset time:
trials = cbind(trials, 
               data.frame(blink_window=dfy(raw_data[grepl('BLINK_WINDOW_ONSET', raw_data)], 
                                            c(3,5), 2)))
# Adding response onset time:
trials = cbind(trials, 
               data.frame(blink_window=dfy(raw_data[grepl('RESPONSE_ONSET', raw_data)], 
                                            c(3,5), 2)))
# Renaming columns to prettier variable names:
colnames(trials) = c('trial_sample_beg', 'trial_time_beg', 
                     'trial_sample_end', 'trial_time_end',
                     'cue_sample', 'cue_time', 'blink_latency_sample', 'blink_latency_time',
                     'blink_window_sample', 'blink_window_time', 'resp_sample', 'resp_time')
# For sample rate check, the last column should be all 1000 (corresponding to Hz):
trials$tot_trial_samples = trials$trial_sample_end - trials$trial_sample_beg
trials$tot_trial_time = trials$trial_time_end - trials$trial_time_beg
trials$samples_per_s = trials$tot_trial_samples / trials$tot_trial_time
print(trials)
```

## Labeling samples
```{r}
# Labeling trials in the 'samples' data frame
samples$time = 0
samples$trial = 0
for(cur_trial in 1:nrow(trials)){
    samples$trial[samples$sample>=trials$trial_sample_beg[cur_trial]] = cur_trial
    samples$time[samples$trial==cur_trial] = (samples$sample[samples$trial==cur_trial] - 
                           trials$trial_sample_beg[cur_trial]) * 0.001
}
print(head(samples))
```

## Blank events
```{r}
# Extracting the lines with blank ends, as they include blank start, end, and duration:
blanks = dfy(raw_data[grepl('^EBLINK', raw_data)], c(6,2,3), 1)
colnames(blanks) = c('blank_sample_beg', 'blank_sample_end', 'tot_blink_samples')
# Labeling trials in the 'blanks' data frame
blanks$trial = 0
blanks$blank_time_beg = 0
blanks$blank_time_end = 0
for(cur_trial in 1:nrow(trials)){
    blanks$trial[blanks$blank_sample_beg>=trials$trial_sample_beg[cur_trial]] = cur_trial
    blanks$blank_time_beg[blanks$trial==cur_trial] =
        (blanks$blank_sample_beg[blanks$trial==cur_trial] - 
           trials$trial_sample_beg[cur_trial]) * 0.001
    blanks$blank_time_end[blanks$trial==cur_trial] =
        (blanks$blank_sample_end[blanks$trial==cur_trial] - 
           trials$trial_sample_beg[cur_trial]) * 0.001
}
print(head(blanks))
```

# Visualization for QC
```{r, fig.width=4.5, fig.height=2.5}
library(ggplot2)
# For simplicity, only visualizing the right eye at the moment:
ylims = c(0, 1000)
for(cur_trial in 1:nrow(trials)){
    p = ggplot(samples[samples$trial==cur_trial,], aes(x=time))
    p = p + geom_line(aes(y=yr, colour='Gaze'))
    p = p + geom_line(aes(y=psr/5, colour='Pupil'))
    p = p + scale_y_continuous(sec.axis = sec_axis(~.*5, name='Pupil Diameter (a.u.)'),
                               limits=ylims)
    p = p + xlim(0, 3)
    p = p + scale_colour_manual(values=c('blue', 'red'))
    p = p + theme(legend.position = c(0.15, 0.2))
    # number of blanks in this trial:
    numof_blanks = sum(blanks$trial==cur_trial)
    if(numof_blanks >= 1){
        cur_blanks = blanks[blanks$trial==cur_trial,]
        for(cur_blank in 1:numof_blanks){
            p = p + geom_rect(data=cur_blanks[cur_blank,], inherit.aes=F, 
                              aes(xmin=blank_time_beg, xmax=blank_time_end, 
                                  ymin=ylims[1], ymax=ylims[2]),
                              color='transparent', fill='purple', alpha=.3)
        }
    }
    # Marking the cue:
    p = p + geom_rect(data=trials[cur_trial,], inherit.aes=F, 
                      aes(xmin=cue_time-trial_time_beg, xmax=cue_time+.2-trial_time_beg, 
                          ymin=ylims[1], ymax=ylims[2]),
                      color='transparent', fill='orange', alpha=.3)
    # Marking the supposed blink time window:
    p = p + geom_rect(data=trials[cur_trial,], inherit.aes=F, 
                      aes(xmin=blink_window_time-trial_time_beg, 
                          xmax=blink_window_time+.3-trial_time_beg, 
                          ymin=ylims[1], ymax=ylims[2]),
                      color='transparent', fill='green', alpha=.3)
    p = p + labs(y='Gaze Y-Position', x='Time', colour='Parameter')
    p = p + ggtitle(paste('Trial #', as.character(cur_trial))) + theme_bw()
    print(p)
}
```

# Trial exclusions
```{r}
# trials_to_exclude = c(4:5)
# # Logging which trials are marked for exclusion:
# write.table(trials_to_exclude, paste(this_data_dir, 'exclude_trials.csv', sep='/'),
#             row.names=F, col.names=F, sep=',')
# # Tagging trial numbers in a separate column:
# df_beeps$trial = as.numeric(rownames(df_beeps))
# # To convert latency to seconds, we need to first compare sample count with measured time:
# df_beeps$tot_blink_samples = df_beeps$blank_sample_end - df_beeps$blank_sample_beg
# df_beeps$tot_time = df_beeps$blank_time_end - df_beeps$blank_time_beg
# df_beeps$sample_per_s = df_beeps$tot_time / df_beeps$tot_blink_samples
# # To detemine blink latency, merging blanks with beeps data sets:
# df_aggr = merge(blanks, df_beeps, by='trial')
# # Excluding the trials that didn't pass QC:
# df_aggr = df_aggr[!df_aggr$trial %in% trials_to_exclude, ]
# # Computing blink latency:
# df_aggr$latency_samples = df_aggr$blank_sample_beg.x - df_aggr$blank_sample_end.y
# df_aggr$latency_time = df_aggr$latency_samples * df_aggr$sample_per_s
# # Computing blink duration:
# df_aggr$blink_duration = df_aggr$tot_samples.x * df_aggr$sample_per_s
# # Selecting columns for output and printing:
# select_cols = c('trial','latency_time','blink_duration')
# sub_df = df_aggr[,select_cols]
# write.csv(sub_df, paste(this_data_dir, 'blink_params.csv', sep='/'), row.names=F)
# print(sub_df)
```