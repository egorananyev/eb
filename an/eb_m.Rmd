---
title: "[eb1] Measurement - Quality Control"
author: "Egor Ananyev"
date: "2019-01-04"
output:
    html_document:
        toc: true
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body, td{
  font-family: Cambria;
}
code.r{
  font-family: Inconsolata;
}
</style>

# Data input and parsing
```{r set-options, message=F}
options(width=80)
dropbox_dir = '/Users/Egor/Dropbox/' # Mac / Toshi
# dropbox_dir = '/Users/egora/Dropbox/' # Shocky
data_dir = paste0(dropbox_dir, 'Projects/eb/data/eb1')
this_subj = 'subj-00'
this_cond = 'cond-m'
cond_dir = paste(data_dir, this_subj, this_cond, sep='/')
all_data_dirs = list.dirs(cond_dir)[-1]  # excluding the first (base) directory
# TEMP: for now, just taking the last directory:
this_data_dir = all_data_dirs[length(all_data_dirs)]
file_name = dir(this_data_dir, pattern='.asc.gz')
file_path = paste(this_data_dir, file_name, sep='/')
```

```{r}
# Read in the data:
raw_data = readLines(gzfile(file_path))  # gzfile unpacks .gz

# This function converts a specific chunk of raw data into a numeric data frame.
dfy = function(df_in, cols, space_col=0){
    ## The 'cols' parameter identifies the number of columns that are tab-delimited
    ## The 'space_col' parameter allows specification of _one_ column to delimit by space
    if(space_col == 0){
        # split the dataset by the tab '\t' delimeter:
        df_out = do.call(rbind, strsplit(df_in, '\t'))[,cols]
    }else{
        # split the dataset by the tab '\t' delimeter:
        df_out = data.frame(do.call(rbind, strsplit(df_in, "\t", fixed=TRUE)))
        # split the data set by space ' ' delimeter:
        df_out = cbind(df_out, data.frame(do.call(rbind, 
                                                  strsplit(as.character(df_out[,space_col])," ", 
                                                           fixed=TRUE))))
        df_out = df_out[,cols]
    }
    # We then convert the resulting character matrix into a numeric data frame:
    if(is.null(dim(df_out))){  # if there is only a single dimension (i.e., a list), no need for 'apply'
        df_out = as.numeric(df_out)
    }else{  # otherwise, 'apply'ing 'as.numeric' conversion to columns:
        if(space_col == 0){
            # To avoid the 'conversion to NA' warning, preassigning blink-related ROWS to NAs:
            df_out[df_out=='   .'] = NA
            df_out = data.frame(apply(df_out[,cols], 2, as.numeric))
        }else{
            df_out = data.frame(apply(df_out, 2, as.numeric))
        }
    }
    return(df_out)
}
```

## Samples
```{r}
# extracting lines that start with numbers:
samples = raw_data[grepl('^[0-9]', raw_data)]
# creating a proper data frame:
df_samples = dfy(samples, 1:4, 0)  # we only need 4 cols, and no columns are space-delimited
colnames(df_samples) = c('sample', 'xr', 'yr', 'psr')
print(head(df_samples))
```

## Trial times
```{r}
# Storing the start and end trials times for later labeling
df_trials = data.frame(start=dfy(raw_data[grepl('TRIAL_START', raw_data)], c(3,5), 2),
                       end=dfy(raw_data[grepl('TRIAL_END', raw_data)], c(3,5), 2))
colnames(df_trials) = c('start_sample', 'start_time', 'end_sample', 'end_time')
df_trials$tot_samples = df_trials$end_sample - df_trials$start_sample
df_trials$tot_time = df_trials$end_time - df_trials$start_time
df_trials$samples_per_s = df_trials$tot_samples / df_trials$tot_time
print(head(df_trials))
```

```{r}
# Storing the start and end beep times
df_beeps = data.frame(start=dfy(raw_data[grepl('BEEP_START', raw_data)], c(3,5), 2),
                       end=dfy(raw_data[grepl('BEEP_END', raw_data)], c(3,5), 2))
colnames(df_beeps) = c('start_sample', 'start_time', 'end_sample', 'end_time')
df_beeps$tot_samples = df_beeps$end_sample - df_beeps$start_sample
df_beeps$tot_time = df_beeps$end_time - df_beeps$start_time
df_beeps$samples_per_s = df_beeps$tot_samples / df_beeps$tot_time
print(head(df_beeps))
```

```{r}
# Labeling trials in the 'samples' data frame
df_samples$time = 0
df_samples$trial = 0
for(cur_trial in 1:nrow(df_trials)){
    df_samples$trial[df_samples$sample >= 
                         df_trials$start_sample[cur_trial]] = cur_trial
    df_samples$time[df_samples$trial==cur_trial] = 
        (df_samples$sample[df_samples$trial==cur_trial] - 
                           df_trials$start_sample[cur_trial]) * 0.001
}
print(head(df_samples))
```

## Beep times
```{r}
df_beeps$trial_start_time = 0
df_beeps$trial_end_time = 0
df_beeps$trial = as.numeric(rownames(df_beeps))
for(cur_trial in 1:nrow(df_trials)){
    df_beeps$trial_start_time[df_beeps$trial==cur_trial] = 
        df_beeps$start_time[df_beeps$trial==cur_trial] - df_trials$start_time[cur_trial]
    df_beeps$trial_end_time[df_beeps$trial==cur_trial] = 
        df_beeps$end_time[df_beeps$trial==cur_trial] - df_trials$start_time[cur_trial]
}
print(df_beeps)
```

## Blank events
```{r}
# Extracting the lines with blank ends, as they include blank start, end, and duration:
df_blanks = dfy(raw_data[grepl('^EBLINK', raw_data)], c(6,2,3), 1)
colnames(df_blanks) = c('start_sample', 'end_sample', 'tot_samples')
# Labeling trials in the 'blanks' data frame
df_blanks$trial = 0
df_blanks$start_time = 0
df_blanks$end_time = 0
for(cur_trial in 1:nrow(df_trials)){
    df_blanks$trial[df_blanks$start_sample >= df_trials$start_sample[cur_trial]] = cur_trial
    df_blanks$start_time[df_blanks$trial==cur_trial] =
        (df_blanks$start_sample[df_blanks$trial==cur_trial] - df_trials$start_sample[cur_trial]) *
        0.001
    df_blanks$end_time[df_blanks$trial==cur_trial] =
        (df_blanks$end_sample[df_blanks$trial==cur_trial] - df_trials$start_sample[cur_trial]) *
        0.001
}
print(head(df_blanks))
# TODO: the blank durations tend to be overestimated by 2 units
```

# Visualization for QC
```{r, fig.width=4.5, fig.height=2.5}
library(ggplot2)
# For simplicity, only visualizing the right eye at the moment:
ylims = c(0, 1000)
for(cur_trial in 1:nrow(df_trials)){
    p = ggplot(df_samples[df_samples$trial==cur_trial,], aes(x=time))
    p = p + geom_line(aes(y=yr, colour='Gaze'))
    p = p + geom_line(aes(y=psr/5, colour='Pupil'))
    p = p + scale_y_continuous(sec.axis = sec_axis(~.*5, name='Pupil Diameter (a.u.)'),
                               limits=ylims)
    p = p + scale_colour_manual(values=c('blue', 'red'))
    p = p + theme(legend.position = c(0.15, 0.2))
    # number of blanks in this trial:
    numof_blanks = sum(df_blanks$trial==cur_trial)
    if(numof_blanks >= 1){
        cur_blanks = df_blanks[df_blanks$trial==cur_trial,]
        for(cur_blank in 1:numof_blanks){
            p = p + geom_rect(data=cur_blanks[cur_blank,], inherit.aes=F, 
                              aes(xmin=start_time, xmax=end_time, 
                                  ymin=ylims[1], ymax=ylims[2]),
                              color='transparent', fill='purple', alpha=.3)
        }
    }
    p = p + geom_rect(data=df_beeps[cur_trial,], inherit.aes=F, 
                      aes(xmin=trial_start_time, xmax=trial_end_time, 
                          ymin=ylims[1], ymax=ylims[2]),
                      color='transparent', fill='orange', alpha=.3)
    p = p + geom_rect(data=df_beeps[cur_trial,], inherit.aes=F, 
                      aes(xmin=trial_end_time+.5, xmax=trial_end_time+.8, 
                          ymin=ylims[1], ymax=ylims[2]),
                      color='transparent', fill='yellow', alpha=.3)
    p = p + labs(y='Gaze Y-Position', x='Time', colour='Parameter')
    p = p + ggtitle(paste('Trial #', as.character(cur_trial))) + theme_bw()
    print(p)
}
```

# Trial exclusions
```{r}
trials_to_exclude = c(4:5)
# Logging which trials are marked for exclusion:
write.table(trials_to_exclude, paste(this_data_dir, 'exclude_trials.csv', sep='/'),
            row.names=F, col.names=F, sep=',')
# Tagging trial numbers in a separate column:
df_beeps$trial = as.numeric(rownames(df_beeps))
# To convert latency to seconds, we need to first compare sample count with measured time:
df_beeps$tot_samples = df_beeps$end_sample - df_beeps$start_sample
df_beeps$tot_time = df_beeps$end_time - df_beeps$start_time
df_beeps$sample_per_s = df_beeps$tot_time / df_beeps$tot_samples
# To detemine blink latency, merging blanks with beeps data sets:
df_aggr = merge(df_blanks, df_beeps, by='trial')
# Excluding the trials that didn't pass QC:
df_aggr = df_aggr[!df_aggr$trial %in% trials_to_exclude, ]
# Computing blink latency:
df_aggr$latency_samples = df_aggr$start_sample.x - df_aggr$end_sample.y
df_aggr$latency_time = df_aggr$latency_samples * df_aggr$sample_per_s
# Computing blink duration:
df_aggr$blink_duration = df_aggr$tot_samples.x * df_aggr$sample_per_s
# Selecting columns for output and printing:
select_cols = c('trial','latency_time','blink_duration')
sub_df = df_aggr[,select_cols]
write.csv(sub_df, paste(this_data_dir, 'blink_params.csv', sep='/'), row.names=F)
print(sub_df)
```