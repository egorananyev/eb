---
title: "[eb1] Analyses"
author: "Egor Ananyev"
date: "2019-01-04"
output:
    html_document:
        toc: true
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body, td{
  font-family: Cambria;
}
code.r{
  font-family: Inconsolata;
}
</style>

# Data input and parsing
```{r set-options, message=F}
options(width=100)
computer = 'shocky'  # 'shocky', 'station3', 'acer' are all possible options
debug = F
short_rt_cutoff = 0.2
long_rt_cutoff = 1
library(plyr)
library(dplyr)
library(ggplot2)
library(lme4)
if(computer == 'shocky'){ dropbox_dir='/Users/Egor/Dropbox/' }
if(computer == 'acer'){ dropbox_dir='/Users/egora/Dropbox/' }
source(paste(dropbox_dir, 'Projects/eb/eb/an/funs/BF_t.R', sep='/'))
source(paste(dropbox_dir, 'Projects/eb/eb/an/funs/BF_U.R', sep='/'))
all_data_dir = paste0(dropbox_dir, 'Projects/eb/data/eb1/')
conds = c('cond-a', 'cond-c', 'cond-v')
cue_conds = c('cp', 'cu')  # cue predictive and unpredictive
ds = data.frame()
et = data.frame()
excl = data.frame()
# cur_cue_cond = cue_conds[1]
for(cur_cue_cond in cue_conds){
  cur_cue_bin = as.numeric(cur_cue_cond == 'cp')  # binary variable for whether the cue is pred've
  data_dir = paste0(all_data_dir, cur_cue_cond, '/')
  subjs = dir(data_dir, pattern='subj-')
  # subjs = subjs[1:10]  # temp
  # cur_subj = subjs[1]  # temp
  for(cur_subj in subjs){
    cur_subj_dir = paste0(data_dir, cur_subj)
    # cur_cond = conds[1]  # temp
    for(cur_cond in conds){
      cur_cond_dir = paste(cur_subj_dir, cur_cond, sep='/')
      sesss = dir(cur_cond_dir, pattern='sess-')
      # cur_sess = sesss[1]  # temp
      for(cur_sess in sesss){
        cur_sess_dir = paste(cur_cond_dir, cur_sess, sep='/')
        # print(cur_sess_dir)
        cur_ds = read.csv(paste(cur_sess_dir, 'beh_out.csv', sep='/'))
        # Making sure 'cue_pred' column exists; if not, writing it in:
        if(!'cue_pred' %in% colnames(cur_ds)){
          cur_ds$cue_pred = cur_cue_bin
        } else {
          if(unique(cur_ds$cue_pred) != cur_cue_bin){
            print('ERROR! Cue predictiveness condition does not match the data!')
          }
        }
        # Same for target SOA:
        if(!'targ_soa' %in% colnames(cur_ds)){ cur_ds$targ_soa = 0 }
        # Reading the eye-tracking data:
        cur_et = read.csv(paste(cur_sess_dir, 'eye_tracking.csv', sep='/'))
        # "unique" function helps resolve disparities in folder naming & data set values:
        cur_et = cbind(data.frame(subj=unique(cur_ds$subj),
                                  cue_pred=cur_cue_bin, 
                                  cond=unique(cur_ds$cond), 
                                  sess=unique(cur_ds$sess)),
                       cur_et)
        # For eye-tracking data, making sure that the extra columns from AB cond are present:
        if(!cur_cond == 'cond-a'){
          cur_et = cbind(cur_et,
                         data.frame(shutter_sample_beg = NA, shutter_time_beg = NA,
                                    shutter_sample_end = NA, shutter_time_end = NA,
                                    cue_resp_sample = NA, cue_resp_time = NA))
        }
        # print(colnames(cur_ds))  # debug
        # ds = cur_ds  # temp
        ds = rbind(ds, cur_ds)
        et = rbind(et, cur_et)
        excl_file = paste(cur_sess_dir, 'exclude_trials.csv', sep='/')
        if(file.exists(excl_file)){
          excl_file_ds = read.csv(excl_file)
          if(nrow(excl_file_ds) > 0){
            cur_excl = cbind(data.frame(subj=as.numeric(substr(cur_subj, 6, 7)), 
                                        cue_pred=cur_cue_bin,
                                        cond=substr(cur_cond, 6, 6),
                                        sess=as.numeric(substr(cur_sess, 6, 6))), excl_file_ds)
            excl = rbind(excl, cur_excl)
          }
        }
      }
    }
  }
}
colnames(ds)[5] = 'trial'  # renaming the 'trial_id' column to 'trial'
head(ds)
# print(excl)
```

# Cleaning the data
```{r}
# Excluding trials with RTs that are too short (below 200 ms)
excl_short = ds[ds$rt<short_rt_cutoff, c('subj', 'cue_pred', 'cond', 'sess', 'trial')]
if(nrow(excl_short) > 0){  # if there are any trials to exclude based on the short RTs
  colnames(excl_short)[5] = 'trial'  # renaming the 'trial_id' column to 'trial'
  excl_short$excl_reason = 'short RT'  # including exclusion reason
  ## Adding the short trials to the common exclusion list:
  excl = rbind(excl, excl_short)
  rownames(excl) <- NULL
}
excl_long = ds[ds$rt>long_rt_cutoff, c('subj', 'cue_pred', 'cond', 'sess', 'trial')]
if(nrow(excl_long) > 0){
  colnames(excl_long)[5] = 'trial'  # renaming the 'trial_id' column to 'trial'
  excl_long$excl_reason = 'long RT'  # including exclusion reason
  excl = rbind(excl, excl_long)
  rownames(excl) <- NULL
}
excl_false = ds[ds$corr_resp==0, c('subj', 'cue_pred', 'cond', 'sess', 'trial')]
if(nrow(excl_false) > 0){
  colnames(excl_false)[5] = 'trial'  # renaming the 'trial_id' column to 'trial'
  excl_false$excl_reason = 'incorrect response'  # including exclusion reason
  excl = rbind(excl, excl_false)
  rownames(excl) <- NULL
}
# Displaying number of trials to be excluded, based on condition and session
ddply(excl, .(subj, cue_pred, cond, excl_reason), summarise, num_excl = length(trial))
# Excluding trials based on the quality control & the RT exclusion criteria:
ds = anti_join(ds, excl, by=c('subj', 'cue_pred', 'cond', 'sess', 'trial'))
```

# Better condition names
```{r}
ds$Cond = 'NoBlink'
ds$Cond[ds$cond=='a'] = 'Artificial'
ds$Cond[ds$cond=='v'] = 'Prompted'
ds$CondFull = 'No Blink'
ds$CondFull[ds$cond=='a'] = 'Artificial Blink'
ds$CondFull[ds$cond=='v'] = 'Prompted Blink'
ds$CuePred = 'Predictive'
ds$CuePred[ds$cue_pred==0] = 'Unpredictive'
ds$CuePredFull = 'Predictive Cue'
ds$CuePredFull[ds$cue_pred==0] = 'Unpredictive Cue'
ds$CueValid = 'Valid'
ds$CueValid[ds$cue_valid==0] = 'Invalid'
# Centered variables:
ds$cue_valid_c = ds$cue_valid
ds$cue_valid_c[ds$cue_valid==0] = -1
ds$cue_pred_c = ds$cue_pred
ds$cue_pred_c[ds$cue_pred==0] = -1
# Reaction time:
ds$RT = 1000 * ds$rt
```

# Merging eye tracking and behavioral data
```{r}
# For analyzing eye blink parameters alongside behavioral data, only prompted blink cond is meaningful:
et_filt = et[et$cond=='v',]
# (This could have been done at the input stage, but I may need post-trial blinks at some point.)

# In the <eb> dataset, only keeping blinks that occurs between the cue and the target:
et_filt2 = et_filt[(et_filt$blank_sample_beg > et_filt$cue_sample) & 
               (et_filt$blank_sample_end < et_filt$targ_sample) &
               (!is.na(et_filt$blank_sample_beg)),]
# CHECK: Test row to check if the above works:
# ( et_filt[et_filt$subj==3 & et_filt$sess==1 & et_filt$cond=='v' & et_filt$cue_pred==1 & et_filt$trial==11,] )
# ( et_filt2[et_filt2$subj==3 & et_filt2$sess==1 & et_filt2$cond=='v' & et_filt2$cue_pred==1 & et_filt2$trial==11,] )

# Also excluding trials with more than one blink in the above time frame:
num_blanks = ddply(et_filt2, .(subj, cue_pred, cond, sess, trial), 
                   summarise, num_blanks = length(trial))
et_filt3 = anti_join(et_filt2, num_blanks[num_blanks$num_blanks>1,],
                    by=c('subj', 'cue_pred', 'cond', 'sess', 'trial'))
# CHECK: Based on the above filter, the following number of blanks (rows) should have been removed:
# sum(num_blanks[num_blanks$num_blanks>1,'num_blanks'])  # should be the same as:
# nrow(et_filt2) - nrow(et_filt3)

# Merging:
dsa = merge(ds[ds$cond=='v',], et_filt3, by=c('subj', 'cue_pred', 'sess', 'trial'))
```

# Summary stats
```{r}
ddply(ds, .(subj, cue_pred, cond, cue_valid), summarise, mean_RT = mean(RT))
```

# Visualization
## Cueing
```{r, fig.width=3, fig.height=2.5}
# for(cur_cue in unique(ds$cue_pred)){
#   for(cur_subj in unique(ds$subj)){
#     for(cur_cond in c('a','c','v')){
#       cur_ds = ds[ds$cond==cur_cond & ds$subj==cur_subj & ds$cue_pred==cur_cue,]
#       cur_cond_name = unique(cur_ds$CondFull)
#       p = ggplot(data=cur_ds, aes(x=factor(cue_valid), y=RT))
#       p = p + theme_bw() + ylim(short_rt_cutoff, 900)
#       p = p + geom_dotplot(binaxis='y', stackdir='center', dotsize=1, binwidth=.02)
#       p = p + ggtitle(paste('cond', cur_cond_name))
#       suppressWarnings(plot(p))
#     }
#   }
# }
```

```{r, fig.width=3, fig.height=2.5}
for(cur_cue in unique(ds$cue_pred)){
  print('-----------------------------------------------------------------------------------')
  print(paste('cue predictive?', as.character(cur_cue)))
  for(cur_subj in unique(ds$subj)){
    for(cur_cond in c('a','c','v')){
      cur_ds = ds[ds$cond==cur_cond & ds$subj==cur_subj & ds$cue_pred==cur_cue,]
      cur_plot_name = paste0(unique(cur_ds$CondFull), ': ', 'Participant ',
                             as.character(cur_subj))
      p = ggplot(data=cur_ds, aes(x=RT, colour=factor(cue_valid))) + geom_density() +
        theme(legend.position = 'bottom') + ggtitle(cur_plot_name)
      plot(p)
    }
  }
}
```

## Cueing group plots

### Density plots
```{r, fig.width=6, fig.height=2.5}
plot_dens = function(cue_pred_val, plot_title){
  ggplot(data=ds[ds$cue_pred==cue_pred_val,], aes(x=RT, colour=CueValid)) + 
    geom_density() + facet_grid(.~CondFull) + theme(legend.position = 'bottom') + 
    ggtitle(plot_title) + guides(colour=guide_legend(title='Cue Validity'))
}
plot(plot_dens(0, 'Unpredictive Cue'))
plot(plot_dens(1, 'Predictive Cue'))
```

### Box plots
```{r, fig.width=3.5, fig.height=2.5}
sumss = ddply(ds, .(subj, cue_pred, CueValid, Cond), summarise, RT=median(RT))
plot_box = function(cue_pred_val, plot_title){
  ggplot(data=sumss[sumss$cue_pred==cue_pred_val,], aes(x=CueValid, y=RT, colour=CueValid)) + 
    geom_boxplot() + facet_grid(.~Cond) + xlab('Cue Validity') + theme_bw() + #ylim(250,500) +
    theme(legend.position='none', panel.grid.minor=element_blank()) + ggtitle(plot_title)
}
( p = plot(plot_box(0, 'Unpredictive Cue')) )
pdf('box_uc.pdf', width=3.5, height=2.5)
plot(p)
dev.off()
( p = plot(plot_box(1, 'Predictive Cue')) )
pdf('box_pc.pdf', width=3.5, height=2.5)
plot(p)
dev.off()
```

### Cueing advantage (invalid - valid cue)
```{r, fig.width=4.5, fig.height=2.5}
sumss_valid = ddply(ds[ds$CueValid=='Valid',], .(subj, CuePredFull, Cond), summarise, 
                    RT_valid=median(RT))
sumss_invalid = ddply(ds[ds$CueValid=='Invalid',], .(subj, CuePredFull, Cond), summarise, 
                      RT_invalid=median(RT))
sumss_adv = merge(sumss_valid, sumss_invalid, by=c('subj', 'CuePredFull', 'Cond'))
sumss_adv$rt_adv = sumss_adv$RT_invalid - sumss_adv$RT_valid
p = ggplot(data=sumss_adv, aes(x=Cond, y=rt_adv, fill=Cond, alpha=0.5)) + 
    geom_boxplot() + facet_grid(.~CuePredFull) + xlab('Eye Blink Condition') + 
    ylab('RT Invalid - Valid (ms)') + theme_bw() + ylim(-75, 75) +
    geom_dotplot(binaxis='y', stackdir='center', dotsize=2, binwidth=3) + 
    theme(legend.position='none', panel.grid.minor=element_blank(), 
          plot.title = element_text(hjust = 0.5)) + ggtitle('Cueing Advantage')
plot(p)
pdf('box_adv_med.pdf', width=4.5, height=2.5)
plot(p)
```

```{r, fig.width=4.5, fig.height=2.5}
## Violin plots
# p = ggplot(data=sumss_adv, aes(x=Cond, y=rt_adv, fill=Cond)) + 
#     geom_violin() + facet_grid(.~CuePredFull) + xlab('Eye Blink Condition') + 
#     ylab('RT Invalid - Valid (ms)') + theme_bw() + ylim(-100, 100) +
#     geom_point(aes(fill=Cond), size=2, shape=21, alpha=.6, 
#                position=position_jitterdodge(jitter.width=.2)) +
#     theme(legend.position='none', panel.grid.minor=element_blank()) + ggtitle('Cueing Advantage')
# plot(p)
# pdf('box_adv_violin.pdf', width=4.5, height=2.5)
# plot(p)
# dev.off()
```

```{r, fig.width=4.5, fig.height=2.5}
## Same thing but with means instead of medians:
# sumss_valid = ddply(ds[ds$CueValid=='Valid',], .(subj, CuePredFull, Cond), summarise, 
#                     RT_valid=mean(RT))
# sumss_invalid = ddply(ds[ds$CueValid=='Invalid',], .(subj, CuePredFull, Cond), summarise, 
#                       RT_invalid=mean(RT))
# sumss_adv = merge(sumss_valid, sumss_invalid, by=c('subj', 'CuePredFull', 'Cond'))
# sumss_adv$rt_adv = sumss_adv$RT_invalid - sumss_adv$RT_valid
# sumss_adv$rt_adv = sumss_adv$rt_adv * 1000
# p = ggplot(data=sumss_adv, aes(x=Cond, y=rt_adv, fill=Cond, alpha=0.5)) + 
#     geom_boxplot() + facet_grid(.~CuePredFull) + xlab('Eye Blink Condition') + 
#     ylab('RT Invalid - Valid (ms)') + theme_bw() + 
#     theme(legend.position='none', panel.grid.minor=element_blank()) + ggtitle('Cueing Advantage')
# pdf('box_adv_mean.pdf', width=4.5, height=2.5)
# plot(p)
# dev.off()
```

# Analyses

## Linear models
```{r}
# Reordering levels of Condition variable, such that No Blink condition is the reference:
ds$Cond <- factor(ds$Cond, c('Prompted','NoBlink','Artificial')) #this works for lm
summary(lmer(RT~Cond*cue_valid*cue_pred + (1|subj), data=ds))
summary(lm(RT~Cond*cue_valid*cue_pred, data=ds))
summary(lm(RT~Cond*cue_valid_c*cue_pred_c, data=ds))
# summary(lm(RT~Cond*cue_valid*cue_pred, data=ds))  # switch to lme4 for mixed models
# 1 / generalTestBF(RT ~ cond*cue_valid, data=ds, whichModels='top')
# summary(lmer(RT~Cond*cue_valid*cue_pred + (1|subj), data=ds))
## Centered data
# summary(lm(RT~Cond*cue_valid_c*cue_pred_c, data=ds))  # switch to lme4 for mixed models
# summary(lmer(RT~Cond*cue_valid_c*cue_pred_c + (1|subj), data=ds))
## Prompted versus No Blink:
# summary(lmer(RT~Cond*cue_valid*cue_pred + (1|subj), data=ds[ds$Cond!='Artificial',]))
## Prompted versus Artificial Blink:
# summary(lmer(RT~Cond*cue_valid*cue_pred + (1|subj), data=ds[ds$Cond!='NoBlink',]))
```

## Bayes Factor
```{r}
library(BayesFactor)
bf_ss = ds
bf_ss$subj <- factor(bf_ss$subj)
bf_ss$AB = 0
bf_ss$AB[bf_ss$cond=='a'] = 1
bf_ss$PB = 0
bf_ss$PB[bf_ss$cond=='v'] = 1
bf_ss$NB = 0
bf_ss$NB[bf_ss$cond=='c'] = 1
# # Effect of cue validity / predictiveness in the no-blink condition:
# mRes = 1/generalTestBF(RT ~ cue_valid * cue_pred + subj, data=bf_ss[bf_ss$NB==1,], 
#                        whichRandom='subj', neverExclude='subj', whichModels='top')
# print(mRes)
# # Prompted vs No Blink:
# mRes = 1/generalTestBF(RT ~ PB * cue_valid * cue_pred + subj, data=bf_ss[bf_ss$AB==0,], 
#                        whichRandom='subj', neverExclude='subj', whichModels='top')
# print(mRes)
# # Prompted vs Artificial:
# mRes = 1/generalTestBF(RT ~ PB * cue_valid * cue_pred + subj, data=bf_ss[bf_ss$NB==0,], 
#                        whichRandom='subj', neverExclude='subj', whichModels='top')
# print(mRes)
```

### Predictive cue

#### Prompted vs no blink
```{r}
mRes = 1/generalTestBF(RT ~ PB * cue_valid + subj,
                  data=bf_ss[bf_ss$AB==0 & bf_ss$cue_pred==1,], whichRandom='subj', 
                  neverExclude='subj', whichModels='top')
print(mRes)
```

#### Prompted vs artificial blink
```{r}
mRes = 1/generalTestBF(RT ~ PB * cue_valid + subj,
                  data=bf_ss[bf_ss$NB==0 & bf_ss$cue_pred==1,], whichRandom='subj', 
                  neverExclude='subj', whichModels='top')
print(mRes)
```

# Blink-related analysis

## Cleaning up the combined dataset
```{r}
cue_valid_name = 'Cue Validity'
dsa$cue_valid_full = 'Invalid'
dsa$cue_valid_full[dsa$cue_valid==1] = 'Valid'
cue_pred_name = 'Cue Type'
dsa$cue_pred_full = 'Unpredictive Cue'
dsa$cue_pred_full[dsa$cue_pred==1] = 'Predictive Cue'
dsa$blink_target_asynchrony = 1000 * (dsa$targ_time - dsa$trial_start - dsa$blank_time_end)
dsa$blink_target_asynchrony_c = dsa$blink_target_asynchrony - mean(dsa$blink_target_asynchrony)
dsa$tot_blank_time = 1000 * (dsa$tot_blank_time)
dsa$tot_blank_time_c = dsa$tot_blank_time - mean(dsa$tot_blank_time)
dsa$blank_time_beg = 1000 * (dsa$blank_time_beg)
dsa$blank_time_beg_c = dsa$blank_time_beg - mean(dsa$blank_time_beg)
```

## Blink duration
```{r, fig.width=5.5, fig.height=2.5}
bdur_rt = ddply(dsa, .(subj, cue_pred_full, cue_valid_full), summarise,
                bdur = mean(tot_blank_time), RT = mean(RT))
ggplot(bdur_rt, aes(x=bdur, y=RT)) + geom_point(aes(color=factor(cue_valid_full))) + 
  stat_smooth(method='lm', aes(color=factor(cue_valid_full)), alpha=.2) +
  facet_grid(cols=vars(cue_pred_full)) + xlab('Blink Duration (ms)') + ylab('Reaction Time (ms)')+
  guides(colour=guide_legend(title=cue_valid_name)) + theme_bw() + xlim(75, 225) +
  theme(legend.position=c(.09, .75), legend.title=element_blank())
## Linear model:
# summary(lm(rt.x~tot_blank_time*cue_valid*cue_pred, data=dsa))
summary(lmer(rt.x~tot_blank_time*cue_valid*cue_pred + (1|subj), data=dsa))
# summary(lmer(rt.x~tot_blank_time_c*cue_valid_c*cue_pred_c + (1|subj), data=dsa))
```

## Blink latency
```{r, fig.width=5.5, fig.height=2.5}
blat_rt = ddply(dsa, .(subj, cue_pred_full, cue_valid_full), summarise,
                blat = mean(blank_time_beg), RT = mean(rt.x))
ggplot(blat_rt, aes(x=blat, y=RT)) + geom_point(aes(color=factor(cue_valid_full))) + 
  stat_smooth(method='lm', aes(color=factor(cue_valid_full)), alpha=.2) +
  facet_grid(cols=vars(cue_pred_full)) + xlab('Blink Latency (ms)') + ylab('Reaction Time (ms)') +
  guides(colour=guide_legend(title=cue_valid_name)) + theme_bw() + 
  theme(legend.position=c(.09, .75), legend.title=element_blank())
## Linear model:
# summary(lm(rt.x~blank_time_beg*cue_valid*cue_pred, data=dsa))
summary(lmer(RT~blank_time_beg*cue_valid*cue_pred + (1|subj), data=dsa))
# summary(lmer(rt.x~blank_time_beg_c*cue_valid_c*cue_pred_c + (1|subj), data=dsa))
```

## Blink-target asynchrony
```{r, fig.width=5.5, fig.height=2.5}
bota_rt = ddply(dsa, .(subj, cue_pred_full, cue_valid_full), summarise,
                bota = mean(blink_target_asynchrony), RT = mean(rt.x))
ggplot(bota_rt, aes(x=bota, y=RT)) + geom_point(aes(color=factor(cue_valid_full))) + 
  stat_smooth(method='lm', aes(color=factor(cue_valid_full)), alpha=.2) +
  facet_grid(cols=vars(cue_pred_full)) + xlab('Blink Offset to Target Asynchrony (ms)') + 
  ylab('Reaction Time (ms)') + guides(colour=guide_legend(title=cue_valid_name)) + theme_bw() +
  theme(legend.position='none')
## Linear model:
# summary(lm(rt.x~blink_target_asynchrony*cue_valid*cue_pred, data=dsa))
summary(lmer(rt.x~blink_target_asynchrony*cue_valid*cue_pred + (1|subj), data=dsa))
# summary(lmer(rt.x~blink_target_asynchrony*cue_valid_c*cue_pred_c + (1|subj), data=dsa))
```
